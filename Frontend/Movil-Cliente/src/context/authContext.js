// src/context/AuthContext.js
import React, { createContext, useContext, useState, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Alert } from 'react-native';

// üß† Contexto
const AuthContext = createContext();

// ‚è∞ Configuraci√≥n de expiraci√≥n (20 minutos)
const SESSION_TIMEOUT = 20 * 60 * 1000;

// üî§ Utilidades
const norm = (v) => (v ?? '').toString().trim().toLowerCase();
const ALLOWED_USER_TYPES = new Set(['cliente']); // agrega alias si aplica: 'customer', 'client'

// üß© Provider
export const AuthProvider = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [hasCompletedOnboarding, setHasCompletedOnboarding] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [userType, setUserType] = useState(null);
  const [user, setUser] = useState(null);
  const [sessionTimer, setSessionTimer] = useState(null);

  useEffect(() => {
    checkAuthStatus();

    return () => {
      if (sessionTimer) {
        clearTimeout(sessionTimer);
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // üîç Verificar si hay una sesi√≥n guardada
  const checkAuthStatus = async () => {
    try {
      console.log('üîç Verificando sesi√≥n de cliente guardada...');

      const [
        token,
        loginTime,
        onboardingCompleted,
        userData,
        savedUserType,
        clientId,
      ] = await AsyncStorage.multiGet([
        'clientToken',
        'clientLoginTime',
        'onboardingCompleted',
        'clientData',
        'clientUserType',
        'clientId',
      ]).then((pairs) => pairs.map(([, v]) => v));

      if (token && loginTime) {
        const currentTime = Date.now();
        const timeSinceLogin = currentTime - parseInt(loginTime, 10);
        console.log(`‚è∞ Tiempo desde login: ${Math.round(timeSinceLogin / 60000)} min`);

        if (timeSinceLogin < SESSION_TIMEOUT) {
          const remainingTime = SESSION_TIMEOUT - timeSinceLogin;

          // Validar tipo de usuario
          if (!ALLOWED_USER_TYPES.has(norm(savedUserType))) {
            console.log('üö´ Usuario no permitido - cerrando sesi√≥n', { savedUserType });
            await clearAuthData();
            setIsLoading(false);
            return;
          }

          // Restaurar estado
          setIsAuthenticated(true);
          setHasCompletedOnboarding(onboardingCompleted === 'true');
          setUser(userData ? JSON.parse(userData) : null);
          setUserType('Cliente'); // forzamos etiqueta est√°ndar en memoria
          console.log(`‚úÖ Sesi√≥n v√°lida. Expira en: ${Math.round(remainingTime / 60000)} min`);
          console.log(`üìã Cliente ID guardado: ${clientId}`);

          // Programar auto-logout
          startSessionTimer(remainingTime);
        } else {
          console.log('‚ùå Sesi√≥n expirada - limpiando datos');
          await clearAuthData();
          Alert.alert(
            '‚è∞ Sesi√≥n Expirada',
            'Tu sesi√≥n ha expirado por seguridad. Por favor, inicia sesi√≥n nuevamente.',
            [{ text: 'OK' }]
          );
        }
      } else {
        console.log('üì≠ No hay sesi√≥n de cliente guardada');
      }

      setIsLoading(false);
    } catch (error) {
      console.error('‚ùå Error verificando sesi√≥n:', error);
      await clearAuthData();
      setIsLoading(false);
    }
  };

  // ‚è≤Ô∏è Iniciar timer de sesi√≥n
  const startSessionTimer = (timeoutDuration = SESSION_TIMEOUT) => {
    if (sessionTimer) {
      clearTimeout(sessionTimer);
    }

    const timer = setTimeout(async () => {
      console.log('‚è∞ Sesi√≥n de cliente expirada autom√°ticamente');
      await autoLogout();
    }, timeoutDuration);

    setSessionTimer(timer);
    console.log(`‚è∞ Timer de cliente iniciado: ${Math.round(timeoutDuration / 60000)} min`);
  };

  // üö™ Auto-logout por expiraci√≥n
  const autoLogout = async () => {
    try {
      console.log('üîí Cerrando sesi√≥n autom√°ticamente por expiraci√≥n');
      await clearAuthData();
      Alert.alert(
        '‚è∞ Sesi√≥n Expirada',
        'Tu sesi√≥n ha expirado por seguridad. Por favor, inicia sesi√≥n nuevamente.',
        [{ text: 'OK' }]
      );
    } catch (error) {
      console.error('‚ùå Error en auto-logout:', error);
    }
  };

  // üßπ Limpiar todos los datos de autenticaci√≥n
  const clearAuthData = async () => {
    try {
      await AsyncStorage.multiRemove([
        'clientToken',
        'clientLoginTime',
        'onboardingCompleted',
        'clientData',
        'clientUserType',
        'clientId',
        'authToken', // compatibilidad
      ]);

      setIsAuthenticated(false);
      setHasCompletedOnboarding(false);
      setUserType(null);
      setUser(null);

      if (sessionTimer) {
        clearTimeout(sessionTimer);
        setSessionTimer(null);
      }

      console.log('üßπ Datos de cliente limpiados');
    } catch (error) {
      console.error('‚ùå Error limpiando datos:', error);
    }
  };

  // üîê Login con persistencia (solo clientes)
  const login = async (loginData) => {
    try {
      console.log('üîê Procesando login de cliente:', loginData);

      // Validar tipo
      if (!ALLOWED_USER_TYPES.has(norm(loginData?.userType))) {
        return {
          success: false,
          error: `Acceso denegado. Esta app es solo para clientes. Tu tipo: ${loginData?.userType}`,
        };
      }

      // Exigir token real (recomendado)
      if (!loginData?.token) {
        return { success: false, error: 'No se recibi√≥ token del backend' };
      }

      const currentTime = Date.now();
      const userId = loginData?.user?._id || loginData?.user?.id;
      if (!userId) {
        throw new Error('ID de cliente no disponible');
      }

      await AsyncStorage.multiSet([
        ['clientToken', loginData.token],
        ['authToken', loginData.token], // compatibilidad
        ['clientLoginTime', String(currentTime)],
        ['clientData', JSON.stringify(loginData.user)],
        ['clientUserType', 'Cliente'], // est√°ndar interno
        ['clientId', String(userId)],
        ['onboardingCompleted', 'true'], // ‚á¶ si quieres forzar onboarding cambia a 'false'
      ]);

      setUser(loginData.user);
      setUserType('Cliente');
      setIsAuthenticated(true);
      setHasCompletedOnboarding(true); // ‚á¶ si quieres onboarding: false
      startSessionTimer();

      console.log('‚úÖ Login de cliente completado y guardado');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Login error:', error);
      return { success: false, error: error?.message ?? String(error) };
    }
  };

  // üìù Registro (usuarios nuevos - solo clientes)
  const register = async (registrationData) => {
    try {
      console.log('üìù Registrando nuevo cliente:', registrationData);

      const incomingType = norm(registrationData?.userType ?? 'cliente');
      if (!ALLOWED_USER_TYPES.has(incomingType)) {
        return { success: false, error: 'Solo se pueden registrar clientes en esta aplicaci√≥n' };
      }

      const currentTime = Date.now();
      const userId = registrationData?.user?._id || registrationData?.user?.id;
      const realToken = registrationData?.token;

      if (!userId) throw new Error('ID de cliente no disponible');
      if (!realToken) throw new Error('No se recibi√≥ token del backend');

      await AsyncStorage.multiSet([
        ['clientToken', realToken],
        ['authToken', realToken],
        ['clientLoginTime', String(currentTime)],
        ['clientData', JSON.stringify(registrationData.user)],
        ['clientUserType', 'Cliente'],
        ['clientId', String(userId)],
        ['onboardingCompleted', 'false'], // ‚á¶ si quieres saltar onboarding c√°mbialo a 'true'
      ]);

      setUser(registrationData.user);
      setUserType('Cliente');
      setIsAuthenticated(true);
      setHasCompletedOnboarding(false); // ‚á¶ o true si saltas onboarding
      startSessionTimer();

      console.log('üìä Registro de cliente completado');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Register error:', error);
      return { success: false, error: error?.message ?? String(error) };
    }
  };

  // üéâ Completar onboarding
  const completeOnboarding = async () => {
    try {
      await AsyncStorage.setItem('onboardingCompleted', 'true');
      setHasCompletedOnboarding(true);
      console.log('üéâ Onboarding de cliente completado');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Complete onboarding error:', error);
      return { success: false, error: error?.message ?? String(error) };
    }
  };

  // üö™ Logout manual
  const logout = async () => {
    try {
      console.log('üëã Logout manual de cliente');
      await clearAuthData();
      return { success: true };
    } catch (error) {
      console.error('‚ùå Logout error:', error);
      return { success: false, error: error?.message ?? String(error) };
    }
  };

  // üîÑ Renovar sesi√≥n (extender tiempo)
  const refreshSession = async () => {
    try {
      const currentTime = Date.now();
      await AsyncStorage.setItem('clientLoginTime', String(currentTime));
      startSessionTimer(); // reiniciar timer
      console.log('üîÑ Sesi√≥n de cliente renovada por 20 minutos m√°s');
      return { success: true };
    } catch (error) {
      console.error('‚ùå Error renovando sesi√≥n:', error);
      return { success: false, error: error?.message ?? String(error) };
    }
  };

  // ‚è∞ Obtener tiempo restante de sesi√≥n (minutos)
  const getRemainingTime = async () => {
    try {
      const loginTime = await AsyncStorage.getItem('clientLoginTime');
      if (loginTime) {
        const currentTime = Date.now();
        const timeSinceLogin = currentTime - parseInt(loginTime, 10);
        const remainingTime = Math.max(0, SESSION_TIMEOUT - timeSinceLogin);
        return Math.round(remainingTime / 60000);
      }
      return 0;
    } catch (error) {
      console.error('‚ùå Error obteniendo tiempo restante:', error);
      return 0;
    }
  };

  const value = {
    isAuthenticated,
    hasCompletedOnboarding,
    isLoading,
    userType,
    user,
    login,
    register,
    completeOnboarding,
    logout,
    refreshSession,
    getRemainingTime,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// üîó Hook para usar el contexto
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth debe ser usado dentro de AuthProvider');
  }
  return context;
};

export default AuthContext;
